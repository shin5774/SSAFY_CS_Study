# 메모리

### ⏰ 20 min ( 2 combo )

## **First Combo - What is Paging ?**

---

### 1. 논리 주소와 물리 주소에 대한 설명 (사이 관계 또한 기술)

- MMU 단어 필수

![Untitled](%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20630fe23d5e34416a8f6f97c7a81f4ed1/Untitled.png)

> 물리주소는 실제 메모리(DRAM)의 주소를 의미하고 논리 주소는 프로세스가 인식하는 메모리의 가상의 주소를 의미.논리 주소를 통해 사용자는 실제로 무한정한 메모리와 연속된 메모리를 가진것 처럼 보인다. 논리주소는 MMU를 통해 실제 물리 주소를 구해낼수 있다. 실제로 논리주소가 연속된다고해서 이에 매칭되는 물리주소 또한 연속 된다고 볼수 없다.
> 

### 2. 연속 메모리 관리에는 고정 분할 기법과 동적 분할 기법이 존재한다. 2가지 분할 방식에 대해 기술하고 각 경우 발생하는 문제점에 대해 기술

> 고정 분할기법: 프로세스를 고정된 연속적인 크기를 메모리 만큼 할당함. 분할 결정 방식에는 first-fit,best-fit,worst-fit이 존재하고, 이 기법의 문제점은 external fragment가 있다. 동적 분할 기법은 프로세스를 페이지로 나누어서 이에 맞게 프로세스를 동적으로 할당하는 기법을 의미한다 이로인한 문제점은 internal fragment가 있다.
> 

### 3. 외부 단편화의 해결 방법으로는 크게 2가지가 있다. 2가지의 개념에 대해 기술하고 비교

> 압축과 페이징 기법,압축은 외부 단편화의 문제인 hole을 해결하기 위해 메모리를 한곳으로 모는것을 말한다. 페이징은 프로세스를 전체가 아닌 페이지라는 고정된 크기의 단위로 나누어서 각각 할당하는 것을 의미한다. 압축은 사실상 프로세스의 연속적 크기가 유지되는 것이라면 페이징은 그러한 프로세스를 페이지로 쪼개서 넣는것을 의미한다.
> 

### 4. 우리는 이번 장에서 내부 단편화를 해결하는 방법에 대해 배우지 않았습니다. 왜 그럴까 ? (페이징 단어 사용)

> 내부 단편화가 발생하는 원인은 결국 페이지의 크기보다 실제 프로세스가 할당한 양이 적기때문에 발생하는것. 이에 대한 예방책은 페이지의 크기를 줄이는 것인데, 이렇게 되면 페이지 테이블의 크기가 커지기 때문에 역으로 메모리의 손실이 발생할수 있다. 결국 내부 단편화와 페이지 테이블의 크기의 trade-off관계를 고려해야 한다.
> 

## **Second Combo - All About Paging**

---

### 1. 아래 그림의 해시 페이징 방식에 대해 설명

![Untitled](%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20630fe23d5e34416a8f6f97c7a81f4ed1/Untitled%201.png)

> 논리주소의 페이징 인덱스를 해시 함수에 넣어 나온 값을 해시 테이블로 조회해서 나온 물리 메모리의 인덱스와 논리주소에 있는 offset을 통해 물리메모리 주소를 찾음.
> 

### 2. 위 방식에서 같은 키 값을 부여 받은 경우 “연결 리스트”를 이용한다. 위와 같은 방식에서의 문제점과 다른 접근 방법에 대해 기술

> 해당 값을 찾기위해서 최악의 경우 해당 리스트 전체를 탐색해야 할수 있다. 시간을 빠르게 하기 위해 해시의 키 범위를 늘려서 1:1로 매칭되도록 한다 ⇒ 문제점은 메모리 소요가 너무 큼(1:1 관계)
> 

### 3. 다음 프로세스들의 수행에 대해 쓰면 안좋은 페이징 알고리즘을 선택하고 이유를 기술

```
PA : A -> B -> C 
PB : A -> B -> D (A,B,C는 수행을 위한 로직이 저장된 메모리라 생각해라)
```

> 역 페이징 알고리즘, 두 프로세스가 동일한 로직 A,B를 가지게 되는데 역 페이징을 사용하게 되면 동일한 로직에 대해 각 프로세스별로 할당할수 있는 공유 메모리를 사용할수 없게됨. 즉 메모리적 손실이 발생.
>