### ⏰ 20 min ( 2 combo )

## **First Combo - What is Paging ?**

---

### 1. 논리 주소와 물리 주소에 대한 설명 (사이 관계 또한 기술)

- MMU 단어 필수

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/93e932aa-238e-4c21-92c0-b3a86388ec72/d103a13d-7772-485b-906d-814efa7f1e82/Untitled.png)

> 논리 주소는 CPU가 생성한 주소이고, 물리 주소는 실제 메모리가 저장되어 있는 주소이다. 실행 시간에 바인딩된 논리 주소는 물리 주소와 다르기 때문에, MMU를 통해 논리 주소를 물리 주소로 변환하는 과정이 필요하다. 논리 주소 + MMU 값 = 물리 주소
> 

### 2. 연속 메모리 관리에는 고정 분할 기법과 동적 분할 기법이 존재한다. 2가지 분할 방식에 대해 기술하고 각 경우 발생하는 문제점에 대해 기술

> 고정 분할 기법 : 파티션을 다양한 크기로 나누어서 메모리를 알맞은 기준(최적 / 최악 / 최초 적합)에 따라 적재하는 기법
→ 적은 크기의 메모리가 적재되는 경우에 큰 크기의 파티션을 사용해야 하는 경우가 있어 메모리 낭비가 심하다. (내부 단편화 발생)

동적 분할 기법 : 메모리를 동적으로 적재하는 기법
→ 메모리가 적재된 후 삭제하는 과정에서 홀이 발생되는데, 이 때 홀의 크기를 모두 더하면 다른 메모리를 적재할 수 있지만, 홀이 분산되어 있기 때문에 메모리를 적재할 수 없다. (외부 단편화 발생)


### 3. 외부 단편화의 해결 방법으로는 크게 2가지가 있다. 2가지의 개념에 대해 기술하고 비교

> 페이징 기법
: 파티션을 동일한 크기로 나누어서 메모리를 적재하는 기법
압축
: 메모리와 홀을 각각 한 쪽으로 분리하여, 하나의 큰 홀에 계속해서 메모리를 적재하는 기법
> 

### 4. 우리는 이번 장에서 내부 단편화를 해결하는 방법에 대해 배우지 않았습니다. 왜 그럴까 ? (페이징 단어 사용)

> SOL
..세그먼테이션
> 

## **Second Combo - All About Paging**

---

### 1. 아래 그림의 해시 페이징 방식에 대해 설명

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/93e932aa-238e-4c21-92c0-b3a86388ec72/3c518628-5b57-4e38-983f-aae8906b78ec/Untitled.png)

> 각 해시 테이블의 원소는 키, 값, 연결된 포인터의 값을 저장한다. p가 들어오면 해시 테이블에서 연결된 포인터의 값을 통해 원소를 계속해서 탐색하다가 p와 키 값이 동일하면, 해당 원소의 값을 반환한다.
> 

### 2. 위 방식에서 같은 키 값을 부여 받은 경우 “연결 리스트”를 이용한다. 위와 같은 방식에서의 문제점과 다른 접근 방법에 대해 기술

> SOL


### 3. 다음 프로세스들의 수행에 대해 쓰면 안좋은 페이징 알고리즘을 선택하고 이유를 기술

```
PA : A -> B -> C 
PB : A -> B -> D (A,B,C는 수행을 위한 로직이 저장된 메모리라 생각해라)
```

> 역 페이징 방식 
: pid를 통해 메모리의 주소를 가져오는 방식으로, pid 하나 당 하나의 메모리 공간을 사용하기 때문에 공유 메모리를 사용할 수 없다.
>
