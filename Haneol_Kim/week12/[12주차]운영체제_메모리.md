# 메모리

### ⏰ 20 min ( 2 combo )

## **First Combo - What is Paging ?**

---

### 1. 논리 주소와 물리 주소에 대한 설명 (사이 관계 또한 기술)

- MMU 단어 필수

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f77d7a1c-bd05-4f32-aaee-c4f2fdaf935c/d103a13d-7772-485b-906d-814efa7f1e82/Untitled.png)

> SOL
> 
논리 주소의 경우 프로세스가 하나의 메모리를 가지는 환상을 주기 위해 사용하며, CPU의 경우 논리 주소를 사용하게 됩니다. 이를 알맞게 실제 데이터가 저장되어 있는 물리메모리로 맵핑할 필요가 있고 이때 변환을 MMU가 하게 됩니다.

### 2. 연속 메모리 관리에는 고정 분할 기법과 동적 분할 기법이 존재한다. 2가지 분할 방식에 대해 기술하고 각 경우 발생하는 문제점에 대해 기술

> SOL
> 
고정된 영역을 프로세스에게 할당하는 것이다. 
프로세스가 필요 이상 또는 미만의 영역을 할당 받을 수 있다.

동적으로 필요한 만큼을 프로세스에게 할당하는 것이다.
프로세스가 실행되고 종료가 되면 크기가 작은 hole이 여러개 나오게 되며 즉 연속된 메모리 영역이 줄어들게 된다. 이로인해 (외부 단편화가 발생한다.)

### 3. 외부 단편화의 해결 방법으로는 크게 2가지가 있다. 2가지의 개념에 대해 기술하고 비교

> SOL
> 페이징 : 생략


### 4. 우리는 이번 장에서 내부 단편화를 해결하는 방법에 대해 배우지 않았습니다. 왜 그럴까 ? (페이징 단어 사용)

> SOL
> 페이지는 고정된 크기이기 떄문에 내부 단편화를 해결할 수 없다. 예를 들어 페이지의 크기가 1KB이고 1.5KB를 프로세스가 사용하게 되면 페이지 2개가 필요하며 0.5KB는 내부단편화가 발생하게 된다. 이는 고정적인 크기를 가지는 페이지에서는 필연적으로 발생한다.

## **Second Combo - All About Paging**

---

### 1. 아래 그림의 해시 페이징 방식에 대해 설명

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/f77d7a1c-bd05-4f32-aaee-c4f2fdaf935c/3c518628-5b57-4e38-983f-aae8906b78ec/Untitled.png)

> SOL
> 해시 페이지 넘버를 해시를 돌려 index를 찾는다 리스트에는 페이지 번호 프레임 번호 다음 리스트가 저장되어 있으며, 페이지 번호의 경우는 충동이 발생할경우 찾기 위해, 프레임 번호는 물리메모리를 찾기위해 존재한다.

### 2. 위 방식에서 같은 키 값을 부여 받은 경우 “연결 리스트”를 이용한다. 위와 같은 방식에서의 문제점과 다른 접근 방법에 대해 기술

> SOL
> 
위의 경우 연결리스트 것이 문제이다. 즉 해쉬 테이블의 경우 일반적인 경우 시간 복잡도가 매우 좋지만 최악의 경우 시간 복잡도가 n이 될 수 있다. 그러므로 리스트 대신 트리를 사용할 수 있기도 하며, 책에서는 많은 데이터를 포함할 수 있는 클러스터링을 소개하고 있다.

### 3. 다음 프로세스들의 수행에 대해 쓰면 안좋은 페이징 알고리즘을 선택하고 이유를 기술

```
PA : A -> B -> C 
PB : A -> B -> D (A,B,C는 수행을 위한 로직이 저장된 메모리라 생각해라)
```

> SOL
>역 페이징
각 프로세스마다 페이지 테이블을 가지고 있게 될 경우 물리메모리에는 task A와 B 하번만 올라가면 된다. 그러나 역페이징에서는 페이지 테이블에서 PID를 적어두고 프레임과 1대1로 대응시키기 때문에 해당 라이브러리를 사용중인 프로세스에 페이지 테이블에 명시하게 된다. 그러므로 공유task에 대해서 프로세스 마다 각각 올려야 한다. 즉 역페이징을 사용할 경우 task A와 B가 물리메모리에 2번 올라가야 한다. 