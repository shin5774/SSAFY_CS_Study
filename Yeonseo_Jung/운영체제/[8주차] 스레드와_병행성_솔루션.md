# [운영체제] CHAPTER 4. 스레드와 병행성
### ⏰30min

# 1. MultiThreading
## 1-1. 멀티 스레딩의 이점에 대해 설명해주세요.
> sol.   
> 1. 응답성: 응용 프로그램의 일부분이 봉쇄되거나 긴 작업을 수행하더라도 프로그램을 계속 수행하게 하므로 사용자에 대한 응답성을 증가시킨다.  
> 2. 자원 공유: 스레드는 자신이 속한 프로세스의 자원들과 메모리를 공유한다. 즉, 같은 주소 공간 내에 여러 개의 다른 작업을 하는 스레드를 가질 수 있다.
> 3. 경제성: 프로세스는 생성을 위해 메모리와 자원을 할당하는 반면, 스레드는 자신이 속한 프로세스의 자원들을 공유하므로 일반적으로는 이때의 Context Switching이 프로세스 생성보다 시간과 메모리를 덜 소모한다.
> 4. 규모 적응성: 다중 처리기 구조에서는 각각의 스레드가 병렬로 수행될 수 있다.
- 178p

## 1-2. 멀티스레드에서 발생할 수 있는 오버헤드에 대해 설명해주세요.
> sol.
> 1. 컨텍스트 스위칭 오버헤드: 현재 실행 중인 스레드의 상태를 저장하고 다음 실행할 스레드의 상태를 불러오는 과정에서 발생하는 시간과 자원의 소모   
>       멀티 스레드는 멀티 프로세스에 비해 컨텍스트 스위칭 오버헤드가 상대적으로 적지만, 여전히 성능에 영향을 줄 수 있다.
> 2. 동기화 오버헤드: 멀티스레드 환경에서는 여러 스레드가 공유 자원에 동시에 접근하지 못하도록 동기화 메커니즘이 필요. 이러한 동기화 과정에서 발생하는 대기 시간과 자원의 소모  
>     동기화를 위해 사용되는 락(lock)이나 세마포어(semaphore) 등의 메커니즘은 필수적이지만, 과도한 사용은 성능 저하를 초래할 수 있다.
> 3. 메모리 오버헤드: 각 스레드는 자신만의 스택 메모리를 가지며 스레드가 많아질수록 전체 메모리 사용량도 증가하므로, 스레드가 과도하게 많을 경우 시스템의 메모리 부담이 커져 성능 저하나 시스템의 안정성 문제를 일으킬 수 있다.


# 2. MultiThreading+
## 1-1, 1-2를 고려했을 때, 스레드는 많을 수록 성능이 좋을까요?
> sol.   
> 프로세스에 생성되는 오버헤드가 크므로, 새 프로세스가 할 일이 기존 프로세스가 하는 일과 동일하다면 프로세스 안에 여러 스레드를 만드는 것이 더 효율적이다.   
> 또한, 다중스레드 환경은 1-1의 네 가지 이점을 제공하고, 스레드를 많이 쓰면 쓸수록 동시에 더 많은 작업들을 실행할 수 있어 효율적이라고 생각할 수 있다.
> 
> 그러나 스레드 역시 1-2와 같은 오버헤드가 발생하며 스레드를 무한정 만들면 언젠가는 CPU 시간, 메모리 공간 같은 시스템 자원이 고갈된다.
> CPU 소모가 많은 CPU bound 어플리케이션에서 코어 수와 비슷한 수준 이상으로 스레드 수를 늘리는 경우, 오히려 각 코어에서 경합하는 스레드 수가 많아질수록 context switching 때문에 overhead만 더 많아져서 성능에 안 좋은 영향을 줄 수 있다.
> 또한 어플리케이션의 동작이 순차적으로 발생해야 한다는 특징이 있는 경우에는 실제 사용할 수 있는 스레드 수에 한계가 있다.   
> 이외에도 데이터 동기화, 테스트 및 디버깅의 어려움 등으로 고려해야 할 상황이 많고 프로그래밍 난이도가 비교적 높다. 이를 잘 고려하여 프로그래밍해야 한다. 

[참고1.1 - 스레드는 많을 수록 좋을까?](https://easy-code-yo.tistory.com/45)  
[참고1.2 - 스레드는 많을 수록 좋을까?](https://inpa.tistory.com/entry/%F0%9F%91%A9%E2%80%8D%F0%9F%92%BB-Is-more-threads-always-better)  
[참고2 - 싱글 스레드와 멀티 스레드](https://velog.io/@ahsy92/%EA%B8%B0%EC%88%A0%EB%A9%B4%EC%A0%91-%EC%8B%B1%EA%B8%80%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80-%EB%A9%80%ED%8B%B0%EC%8A%A4%EB%A0%88%EB%93%9C)  
[참고3 - 프로세스와 스레드의 컨텍스트 스위칭](https://engineerinsight.tistory.com/284)


# 3. 스레드 풀
## 스레드 풀에 대해 설명해주세요. 
> sol.   
> 일정한 수의 스레드들을 미리 풀로 만들어 두는 방식을 의미한다.      
> 병렬 처리가 많아지면 스레드 수가 많아지고, 그에 따른 스레드 생성과 스케줄링으로 인해 CPU가 바빠져서 메모리 사용량이 늘어난다. 이는 애플리케이션 성능 저하로 이어지므로
> 서비스할 때마다 스레드를 생성하는 데 소요되는 시간을 줄이고, 스레드를 무한정 만들어 자원이 고갈되지 않도록 하기 해 고안되었다.  
> 작업 처리에 사용되는 스레드를 제한된 개수만큼 정해 놓고, 작업 큐에 들어오는 작업들을 하나씩 스레드가 맡아 처리하는 기법이다.
> 
> 동작 방식: 요청 시 서버는 스레드 풀에 제출하고 추가 요청을 대기한다. 풀에 사용 가능한 스레드가 있다면 요청이 서비스되며, 스레드가 없다면 사용 가능한 스레드가 생길 때까지 대기한다. 스레드가 서비스를 완료하면 풀로 돌아가 작업을 기다린다.   
> 
> 보통 새 스레드를 생성하는 것보다 기존 스레드로 서비스하는 것이 더 빠르며, 스레드 개수에 제한을 두어 많은 수의 스레드를 병렬처리할 수 없는 시스템에 효과적이다. 테스크 생성과 실행을 분리하여 테스크를 일정 시간 후에 실행되거나 주기적으로 실행하도록 스케줄하는 것도 가능해진다. 
> 
 
- 195p

# 4. 스레드 수준
## 스레드의 두가지 수준에 대해 설명해 주세요.
> sol.   
> 사용자 수준 스레드와 커널 수준 스레드가 있다.     
> 사용자 스레드의 커널 위에서 지원되며 커널의 지원 없이 관리되는 반면 커널 스레드는 운영체제에 의해 직접 지원되고 관리된다. 대부분의 현대 운영체제는 커널 스레드를 지원한다.  
> 커널 스레드는 프로세스로부터 분리 되어 있는 반면 모든 사용자 스레드는 프로세스에 포함되어 있다. 
> 커널 스레드는 유저 스레드보다 유지 관리 비용이 많이 드나 IO 작업이 많을 경우에는 커널 스레드가 유리해질 수도 있다.
> 
> 사용자 스레드와 커널 스레드의 연관관계
> 
> | 비고 | 다대일                                                            | 일대일                                                         | 다대다                                                                                                                                      |
> |:---|:---------------------------------------------------------------|:------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------|
> | 사상 | 다중 사용자 수준 스레드 - 단일 커널 스레드                                      | 단일 사용자 스레드 - 단일 커널 스레드                                      | 다중 사용자 수준 스레드 - 다중 커널 수준 스레드(사용자 수준 스레드보다 작거나 같은 수)                                                                                      |
> | 특징 | 사용자 공간의 스레드 라이브러리에서 스레드를 관리해 효율적                               | 하나의 스레드가 봉쇄적 시스템 콜을 호출하더라도 다른 스레드 실행 가능. 다중 스레드의 병렬 스레드를 허용 | 커널 스레드의 수는 응용 프로그램이나 특정 기계에 따라 결정됨. 개발자가 필요한 만큼 많은 사용자 수준 스레드를 생성할 수 있으면서 다중 처리기에서 병렬로 수행될 수 있음. 스레드가 봉쇄형 콜을 발생시켜도 다른 스레드의 수행을 스케줄할 수 있음 |
> | 단점 | 한 스레드가 봉쇄형 시스템 콜을 할 경우 전체 프로세스가 봉쇄. 한번에 하나의 스레드만이 커널에 접근할 수 있음 | 사용자 스레드를 만들기 위해 해당 커널 스레드를 만들어야 하므로 시스템 성능에 부담을 줄 수 있음      | 구현이 어렵고 시스템의 처리 코어 수가 증가하면서 커널 스레드 수 제한의 중요성이 낮아짐                                                                                        |
> | 예시 | green thread, java 초기 버전                                       | Linux, Windows                                              |                                                                                                                                          |
> + 두 수준 모델: 다대다 모델의 변형으로 사용자 스레드를 이보다 적거나 같은 수의 커널 스레드로 멀티플렉스시키면서 한 사용자 스레드가 하나의 커널 스레드에만 연관되는 것을 허용
> 
> 다대다 모델과 두 수준 모델의 경우 스레드 라이브러리와 커널의 통신 문제를 해결해야 한다. 이때 사용자와 커널 스레드 사이에 경량 프로세스(LWP)라는 중간 자료구조를 사용하여, 커널은 어플리케이션에 LWP 집합을 제공하고 어플리케이션은 사용자 스레드를 가용한 LWP로 스케줄하는 식의 스케줄러 액티베이션을 사용할 수 있다.
- 182p 
# 5. 병행성과 병렬성
## 동시성(병행성)과 병렬성을 설명해주세요.
> sol.  
> 병행성은 모든 작업이 진행되게 하여 둘 이상의 작업을 지원하는 것을, 병렬성은 둘 이상의 작업을 동시에 수행하는 것을 의미한다.
> 즉, 병행성의 경우 여러 작업이 동시에 진행되는 것처럼 보이지만, 실제로는 하나의 CPU에서 번갈아가며 처리되는 것을 말한다. 이와 달리 병렬성은 여러 개의 CPU가 동시에 여러 작업을 처리하는 것을 의미한다.
> 여러 스레드가 진행중인 경우엔 병행성이 존재하는 반면 여러 스레드가 **동시에** 진행된다면 병렬성이 존재한다. 
> 단일 CPU에서는 병행성만 가능하며, 병렬성을 위해서는 여러 CPU를 제공하는 다중 코어 시스템이 필요하다.
- 179p, 215p